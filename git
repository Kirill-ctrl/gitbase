git config --global user.name "Kirill"
git config --global user.email "k.pechurin02@mail.ru"


git config --list

Игнорирование файлов



Создать файл
cd.>git1.txt

централизованный - проект целиком находится на центральном сервере

распределенный - есть версия на центральном сервере, а есть также своя версия
на компах разработчиков

гит является распределенной сиситемой контроля версий

-----

git config --global user.name "Kirill"
git config --global user.email "k.pechurin02@mail.ru"
git config --global color.ui true   ------ Цвет

mkdir test --- создаем папку с названием проекта
cd test  --- перейти в папку нашего проекта
git init  --- производит инициализацию гита в нашем проекте
Это значит, что в нашей папке создалась невидимая папка .гит, которую гит
использует в своей работе


--------

Основы

гит хранит в виде снимков проекта во времени

git add -- Подготавливаем файлы к стадии фиксации
git commit -- делаем снимок наших файлов - фиксируем файлы

modified - Измененный
git commit -m "Сообщение снимка" - сделать коммит


git add file1 file2
git add .
git add *.java
git add someDir/*.java
git add someDir/
git add "*.java"


git log - посмотреть всю историю коммитов

-----------
git diff
показывает разницу между текущим неотслеживаемым состоянием репозитория и
последним снимком репозитория

git diff --staged показывает разницу между текущим отслеживаемым состоянием
репозитория и последним снимком репозитория

git diff COMMIT_ID показывает разницу между текущим состоянием репозитория и
указанным снимком репозитория

------------
git reset
Указатель HEAD

главная ветка - ветка master

Обычно указатель HEAD указывает на последний(текущий) коммит
Указывает на текущую версию проекта

можно смещать
HEAD ^ - на один
HEAD ^^ - на два
Или HEAD ~2 -- на два соответственно

Git reset - 3 Режима
отличаются радикальностью отката к указанному коммиту

--soft   - мягкий
--mixed  - используется по умолчанию
--hard   - отказ радикальный, удаляются изменения и перезаписывается история

git reset [--soft | --mixed | --hard] [commit]
              режим                    хеш коммита или различные вариации HEAD


git reset --hard
Возвращает проект к указанному коммиту, при этом полностью удаляет все коммиты
ПОСЛЕ указанного
Удаляет коммиты безвозвратно

git reset --hard HEAD^^ - на два коммита в прошлое и эти 2 коммита удаляются
полностью

git reset --mixed
Возвращает проект к указанному коммиту, при этом переводит все коммиты ПОСЛЕ
указанного в неотслеживаемую зону
коммиты не удаляются, они переводятся в неотслеживаемую зону

git reset --mixed HEAD^^ - на два коммита в прошлое

git reset --soft
Возвращает к указанному коммиту, при этом переводит все коммиты после
указанного в отслеживаемую зону
git reset --soft HEAD^^

По умолчанию используется режим --mixed

По умолчанию идет HEAD

гит ресет хард не удаляет новые файлы, а удаляет только измененные

Никогда не удалять коммиты в публичном репозитории


------
git checkout

Используется для перемещения между коммитами, версиями отдельных файлов и
перемещения между ветками

вызывается аналогично ресет

Состояние проекта полностью вернется к указанному снимку. При этом никакие
коммиты не удалились. Мы в любой момент можем перенестись обратно в актуальную
версию

Указатель HEAD находится в состоянии DETACHED. Он отделен от актульной версии
проекта. Любые изменения или коммиты, сделанные в этом состоянии удаляются
сборщиком мусора при переходе к другому коммиту


Перемещение между коммитами
git checkout master - переход обратно к актуальному коммиту

master - название текущей ветки

Мы хотим вернуть файл к какой-то версии в прошлом

git checkout 554ui6hu54gnfdjngs584gdfsgif --file1.txt file2

git checkout -- file1 - Возвращаются к версии, которая была у них в последнем
коммите

git checkout --.
Вовзращает все файлы к версии, которая была в последнем коммите

РАБОТАЮТ ТОЛЬКО В НЕОТСЛЕЖИВАЕМЫХ ИЗМЕНЕНИЯХ

Если мы сделали гит эдд

git reset - переводим все отслеживаемые в неотслеживаемые

git checkout --. удалим все неотслеживаемые изменения

=================дополнительные возможности комманды git commit

git commit -a -m - то же самое, что последовательное выполнение git add . и git
 commit -m "Message"

 не добавляет в отслеживаемую зону новые файлы, только модифицированные файлы

 git commit --amend -m "Новое сообщение коммита" - дополняет последний коммит,
 добавляя в него "Свежие" изменения. Также меняет сообщение последнего коммита.
  Новый коммит не создается. Переписывается последний


---------git clean---------
Работает с новыми добавленными файлами

git clean -n = посмотреть какие файлы будут удалены
git clean -f = удалить файлы


------Работы с удаленным репозиторием--------------------
закинуть в гитхаб
push - проталкиваем, пушим на публичный репозиторий
pull - пулить, вытянуть из публичного репозитория к себе на комп и работать над
 ним и потом заливать обратно свои изменения

Github, BitBucket, GitLab

   предоставляет нам всю инфраструктуру для хранения и управления git
   репозиториев

   Просмотр списка существующих удаленных репозиториев
   git remote -v

   git remote add НАЗВАНИЕ_РЕПОЗИТОРИЯ АДРЕС_РЕПОЗИТОРИЯ - добавить новый
   удаленный репозиторий, которых находится по указанному адресу. При этом на
   нашем компе к удаленному репозиторию мы будем обращаться по его названию

   git remote remove НАЗАВАНИЕ_РЕПОЗИТОРИЯ - удалить репозиторий с указанным
   названием

на нашем компьютере хранится только ссылка на удаленный репозиторий, где
НАЗВАНИЕ_РЕПОЗИТОРИЯ - название ссылки

git push - Команда для отправки локального удаленного репозитория
git push НАЗВАНИЕ_УДАЛЕННОГО_РЕПОЗИТОРИЯ ВЕТКА

git push origin master - Отправляет на удаленный репозиторий с именем origin
нашу ветку master

git pull origin master - Получение обновлений с удаленного репозитория
аналогично

fetch = pull практически

https://github.com/Kirill-ctrl/FirstRepository.git


-----SSH Настройка-------

Безопасная оболочка - secure SHell

SSH - Сетевой протокол, позволяющий производить удаленное управление
операционной системой

SSH позволяет безопасно передавать данные в незащищенной среде

github help ssh

-----------git clone------------

git clone git@github.com:Kirill-ctrl/FirstRepository.git
то же самое что pull, просто в одно действие скачиваем все

--------Ветвление-------

новые функции разрабатываются в отдельных ветках

ветка master содержит стабильную версию проекта. Можем вернуться на master в
любой момент

Сразу несколько разработчиков могут работать в своих ветках над своими задачами
. После завершения работы над задачами, эти ветки "Сливаются" в master ветку


git branch название_ветки --- команда для создания новой ветки

git branch some-feature

git branch - команда для просмотра, на какой ветке мы сейчас находимся

git branch -d название_ветки - удалить ветку

git checkout название ветки - перейти на нужную ветку
git checkout some-feature

git merge - сливает одну ветку с другой
git merge add-feature1 - слили ветку add-feature1 в ветку master

Fast-Forward merge

пока мы работали в своей ветке, в ветке мастер ничего не произошло, не было
новых коммитов

гиту очень легко слить ветку add-feature1 в мастер (не возникает конфликтов)

не создается отдельный commit для слияния(merge commit)

пока мы работали в своей ветке, кто то добавил коммиты в ветку мастер

или сами добавили коммиты в ветку мастер

могут возникнуть конфликты. Гит может решить их или самостоятельно, или вручную

merge commit создается

-----------------подробнее о git pull-------------

Скачивает новые коммиты с удаленного репозитория

удаленные ветки - ссылки на состояние веток в удаленных репозиториях

git branch -r - посмотреть ветки, где располагаются
    origin/master

локальные ветки - изменяются только нами
Удаленные ветки - изменяются другими людьми

git pull origin master - запулить к нам ветку мастер

Скачивает удаленную ветку с удаленного репозитория(обновляет ветку
origin/master)

Сливает удаленную ветку с локальной веткой (производит актуализацию вашей
локальной ветки)

то же самое для любой другой ветки (git pull origin название_ветки)

git pull = 1. git fetch
           2. git merge origin/master

команда git fetch "Скачивает" 1) удаленные ветки с репозитория, но не
производит актуализацию ваших локальных веток ( не делает слияния удаленной
ветки с локальной)

как и обычно, слияние может быть fast-forward или не fast-forward(например,
рекурсивное)

-------Конфликты слияния------------

Если изменяли один и тот же файл
КОНФЛИКТ
Гит не сможет слить ветки автоматически
придется решить конфликт вручную

сначала пуллим к себе изменения, открываем файл и выбираем нужный нам вариант
потом add, commit и се пушим на сервер



------удаленные ветки-----------

Чтобы другие люди могли работать над вашей веткой

Чтобы сделать резервную копию вашей локальной ветки

git push --delete origin add-feature1 - Удалить удаленную ветку

git remote show origin - показывает локальные и удаленные ветки

удаление удаленной ветки

юзер1 запушил ветку
юзер 2 запулил ее
юзер 1 удалил ветку и с сервера и с локального
что произойдет если юзер2 захочет запушить эту ветку?
будет создана новая удаленная ветка на гитхабе

--------rebase-----------
перебазирование

rebase - альтернатива merge

обе команды делают одно и то же - сливают ветки

merge может создавать мердж коммит при слиянии, в случае не фаст форвард
rebase мердж коммита не создает

команда merge безопасней. Есть отдельный коммит, отображающий слияние

плюс merge - достоверная полная история коммитов

плюс rebase - лаконичная линейная история без лишних коммитов

Если в ветке долго велась работа, произошло много изменений, лучше использовать
 merge

 если ветка была недолгая и произошло мало изменений - то делаете rebase
